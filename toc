"Common Language Infrastructure (CLI) Partitions I–VI" 4
    "Table of Contents" 5
"Common Language Infrastructure (CLI) Partition I: Concepts and Architecture " 22
    "I.1 Scope" 27
    "I.2 Conformance" 28
    "I.3 Normative references" 29
    "I.4 Conventions" 31
        "I.4.1  Organization" 31
        "I.4.2  Informative text" 31
    "I.5 Terms and definitions" 32
    "I.6 Overview of the Common Language Infrastructure" 35
        "I.6.1  Relationship to type safety" 35
        "I.6.2  Relationship to managed metadata-driven execution" 36
            "I.6.2.1  Managed code" 36
            "I.6.2.2  Managed data" 37
            "I.6.2.3  Summary" 37
    "I.7 Common Language Specification" 38
        "I.7.1  Introduction" 38
        "I.7.2  Views of CLS compliance" 38
            "I.7.2.1  CLS framework" 38
            "I.7.2.2  CLS consumer" 39
            "I.7.2.3  CLS extender" 39
        "I.7.3  CLS compliance" 40
            "I.7.3.1  Marking items as CLS-compliant" 40
    "I.8 Common Type System" 42
        "I.8.1  Relationship to object-oriented programming" 45
        "I.8.2  Values and types" 45
            "I.8.2.1  Value types and reference types" 45
                "I.8.2.1.1  Managed pointers and related types" 46
            "I.8.2.2  Built-in value and reference types" 46
            "I.8.2.3  Classes, interfaces, and objects" 47
            "I.8.2.4  Boxing and unboxing of values" 47
            "I.8.2.5  Identity and equality of values" 48
                "I.8.2.5.1  Identity" 48
                "I.8.2.5.2  Equality" 49
        "I.8.3  Locations" 49
            "I.8.3.1  Assignment-compatible locations" 49
            "I.8.3.2  Coercion" 49
            "I.8.3.3  Casting" 50
        "I.8.4  Type members" 50
            "I.8.4.1  Fields, array elements, and values" 50
            "I.8.4.2  Methods" 50
            "I.8.4.3  Static fields and static methods" 51
            "I.8.4.4  Virtual methods" 51
        "I.8.5  Naming" 51
            "I.8.5.1  Valid names" 51
            "I.8.5.2  Assemblies and scoping" 52
            "I.8.5.3  Visibility, accessibility, and security" 53
                "I.8.5.3.1  Visibility of types" 54
                "I.8.5.3.2  Accessibility of members and nested types" 54
                "I.8.5.3.3  Security permissions" 55
                "I.8.5.3.4  Nested types" 55
        "I.8.6  Contracts" 55
            "I.8.6.1  Signatures" 56
                "I.8.6.1.1  Type signatures" 57
                "I.8.6.1.2  Location signatures" 57
                "I.8.6.1.3  Local signatures" 58
                "I.8.6.1.4  Parameter signatures" 58
                "I.8.6.1.5  Method signatures" 58
                "I.8.6.1.6  Signature Matching" 60
        "I.8.7  Assignment compatibility" 60
            "I.8.7.1  Assignment compatibility for signature types" 63
            "I.8.7.2  Assignment compatibility for location types" 64
            "I.8.7.3  General assignment compatibility" 64
        "I.8.8  Type safety and verification" 65
        "I.8.9  Type definers" 65
            "I.8.9.1  Array types" 66
            "I.8.9.2  Unmanaged pointer types" 67
            "I.8.9.3  Delegates" 67
            "I.8.9.4  Interface type definition" 68
            "I.8.9.5  Class type definition" 69
            "I.8.9.6  Object type definitions" 70
                "I.8.9.6.1  Scope and visibility" 70
                "I.8.9.6.2  Concreteness" 70
                "I.8.9.6.3  Type members" 71
                "I.8.9.6.4  Supporting interface contracts" 71
                "I.8.9.6.5  Supporting class contracts" 72
                "I.8.9.6.6  Constructors" 72
                "I.8.9.6.7  Finalizers" 72
            "I.8.9.7  Value type definition" 73
            "I.8.9.8  Type inheritance" 73
            "I.8.9.9  Object type inheritance" 73
            "I.8.9.10  Value type inheritance" 74
            "I.8.9.11  Interface type derivation" 74
        "I.8.10  Member inheritance" 74
            "I.8.10.1  Field inheritance" 74
            "I.8.10.2  Method inheritance" 74
            "I.8.10.3  Property and event inheritance" 75
            "I.8.10.4  Hiding, overriding, and layout" 75
        "I.8.11  Member definitions" 76
            "I.8.11.1  Method definitions" 76
            "I.8.11.2  Field definitions" 77
            "I.8.11.3  Property definitions" 77
            "I.8.11.4  Event definitions" 78
            "I.8.11.5  Nested type definitions" 78
    "I.9 Metadata" 79
        "I.9.1  Components and assemblies" 79
        "I.9.2  Accessing metadata" 79
            "I.9.2.1  Metadata tokens" 80
            "I.9.2.2  Member signatures in metadata" 80
        "I.9.3  Unmanaged code" 80
        "I.9.4  Method implementation metadata" 80
        "I.9.5  Class layout" 81
        "I.9.6  Assemblies: name scopes for types" 81
        "I.9.7  Metadata extensibility" 82
        "I.9.8  Globals, imports, and exports" 83
        "I.9.9  Scoped statics" 84
    "I.10 Name and type rules for the Common Language Specification" 85
        "I.10.1  Identifiers" 85
        "I.10.2  Overloading" 85
        "I.10.3  Operator overloading" 86
            "I.10.3.1  Unary operators" 86
            "I.10.3.2  Binary operators" 87
            "I.10.3.3  Conversion operators" 88
        "I.10.4  Naming patterns" 88
        "I.10.5  Exceptions" 89
        "I.10.6  Custom attributes" 89
        "I.10.7  Generic types and methods" 90
            "I.10.7.1  Nested type parameter re-declaration" 90
            "I.10.7.2  Type names and arity encoding" 91
            "I.10.7.3  Type constraint re-declaration" 92
            "I.10.7.4  Constraint type restrictions" 93
            "I.10.7.5  Frameworks and accessibility of nested types" 93
            "I.10.7.6  Frameworks and abstract or virtual methods" 94
    "I.11 Collected Common Language Specification rules" 95
    "I.12 Virtual Execution System" 98
        "I.12.1  Supported data types" 98
            "I.12.1.1  Native size: native int, native unsigned int, O and &" 99
                "I.12.1.1.1  Unmanaged pointers as type native unsigned int" 99
                "I.12.1.1.2  Object reference and managed pointer types: O and &" 99
                "I.12.1.1.3  Portability: storing pointers in memory" 100
            "I.12.1.2  Handling of short integer data types" 100
            "I.12.1.3  Handling of floating-point data types" 101
            "I.12.1.4  CIL instructions and numeric types" 102
            "I.12.1.5  CIL instructions and pointer types" 103
            "I.12.1.6  Aggregate data" 104
                "I.12.1.6.1  Homes for values" 104
                "I.12.1.6.2  Operations on value type instances" 105
                "I.12.1.6.3  Opaque classes" 107
        "I.12.2  Module information" 107
        "I.12.3  Machine state" 107
            "I.12.3.1  The global state" 107
            "I.12.3.2  Method state" 108
                "I.12.3.2.1  The evaluation stack" 109
                "I.12.3.2.2  Local variables and arguments" 110
                "I.12.3.2.3  Variable argument lists" 110
                "I.12.3.2.4  Local memory pool" 111
        "I.12.4  Control flow" 111
            "I.12.4.1  Method calls" 112
                "I.12.4.1.1  Call site descriptors" 112
                "I.12.4.1.2  Calling instructions" 112
                "I.12.4.1.3  Computed destinations" 113
                "I.12.4.1.4  Virtual calling convention" 113
                "I.12.4.1.5  Parameter passing" 114
            "I.12.4.2  Exception handling" 115
                "I.12.4.2.1  Exceptions thrown by the CLI" 116
                "I.12.4.2.2  Deriving from exception classes" 117
                "I.12.4.2.3  Resolution exceptions" 117
                "I.12.4.2.4  Timing and choice of exceptions" 118
                "I.12.4.2.5  Overview of exception handling" 118
                "I.12.4.2.6  CIL support for exceptions" 119
                "I.12.4.2.7  Lexical nesting of protected blocks" 119
                "I.12.4.2.8  Control flow restrictions on protected blocks" 120
        "I.12.5  Proxies and remoting" 125
        "I.12.6  Memory model and optimizations" 126
            "I.12.6.1  The memory store" 126
            "I.12.6.2  Alignment" 126
            "I.12.6.3  Byte ordering" 126
            "I.12.6.4  Optimization" 126
            "I.12.6.5  Locks and threads" 127
            "I.12.6.6  Atomic reads and writes" 128
            "I.12.6.7  Volatile reads and writes" 128
            "I.12.6.8  Other memory model issues" 129
"Common Language Infrastructure (CLI) Partition II: Metadata Definition and Semantics  " 130
    "II.1 Introduction" 131
    "II.2 Overview" 132
    "II.3 Validation and verification" 133
    "II.4 Introductory examples" 134
        "II.4.1  “Hello world!”" 134
        "II.4.2  Other examples" 134
    "II.5 General syntax" 135
        "II.5.1  General syntax notation" 135
        "II.5.2  Basic syntax categories" 135
        "II.5.3  Identifiers" 136
        "II.5.4  Labels and lists of labels" 137
        "II.5.5  Lists of hex bytes" 137
        "II.5.6  Floating-point numbers" 137
        "II.5.7  Source line information" 138
        "II.5.8  File names" 138
        "II.5.9  Attributes and metadata" 138
        "II.5.10  ilasm source files" 138
    "II.6 Assemblies, manifests and modules" 140
        "II.6.1  Overview of modules, assemblies, and files" 140
        "II.6.2  Defining an assembly" 141
            "II.6.2.1  Information about the assembly ( AsmDecl )" 141
                "II.6.2.1.1  Hash algorithm" 142
                "II.6.2.1.2  Culture" 142
                "II.6.2.1.3  Originator’s public key" 142
                "II.6.2.1.4  Version numbers" 143
            "II.6.2.2  Manifest resources" 144
            "II.6.2.3  Associating files with an assembly" 144
        "II.6.3  Referencing assemblies" 144
        "II.6.4  Declaring modules" 145
        "II.6.5  Referencing modules" 146
        "II.6.6  Declarations inside a module or assembly" 146
        "II.6.7  Exported type definitions" 146
        "II.6.8  Type forwarders" 147
    "II.7 Types and signatures" 148
        "II.7.1  Types" 148
            "II.7.1.1  modreq and modopt" 149
            "II.7.1.2  pinned" 149
        "II.7.2  Built-in types" 150
        "II.7.3  References to user-defined types ( TypeReference )" 150
        "II.7.4  Native data types" 151
    "II.8 Visibility, accessibility and hiding" 153
        "II.8.1  Visibility of top-level types and accessibility of nested types" 153
        "II.8.2  Accessibility" 153
        "II.8.3  Hiding" 153
    "II.9 Generics" 154
        "II.9.1  Generic type definitions" 154
        "II.9.2  Generics and recursive inheritance graphs" 155
        "II.9.3  Generic method definitions" 156
        "II.9.4  Instantiating generic types" 157
        "II.9.5  Generics variance" 158
        "II.9.6  Assignment compatibility of instantiated types" 158
        "II.9.7  Validity of member signatures" 159
        "II.9.8  Signatures and binding" 160
        "II.9.9  Inheritance and overriding" 161
        "II.9.10  Explicit method overrides" 162
        "II.9.11  Constraints on generic parameters" 163
        "II.9.12  References to members of generic types" 164
    "II.10 Defining types" 165
        "II.10.1  Type header ( ClassHeader )" 165
            "II.10.1.1  Visibility and accessibility attributes" 166
            "II.10.1.2  Type layout attributes" 167
            "II.10.1.3  Type semantics attributes" 167
            "II.10.1.4  Inheritance attributes" 168
            "II.10.1.5  Interoperation attributes" 168
            "II.10.1.6  Special handling attributes" 168
            "II.10.1.7  Generic parameters ( GenPars )" 169
        "II.10.2  Body of a type definition" 172
        "II.10.3  Introducing and overriding virtual methods" 173
            "II.10.3.1  Introducing a virtual method" 173
            "II.10.3.2  The .override directive" 173
            "II.10.3.3  Accessibility and overriding" 174
            "II.10.3.4  Impact of overrides on derived classes" 175
        "II.10.4  Method implementation requirements" 176
        "II.10.5  Special members" 176
            "II.10.5.1  Instance constructor" 176
            "II.10.5.2  Instance finalizer" 177
            "II.10.5.3  Type initializer" 177
                "II.10.5.3.1  Type initialization guarantees" 177
                "II.10.5.3.2  Relaxed guarantees" 178
                "II.10.5.3.3  Races and deadlocks" 178
        "II.10.6  Nested types" 179
        "II.10.7  Controlling instance layout" 179
        "II.10.8  Global fields and methods" 180
    "II.11 Semantics of classes" 182
    "II.12 Semantics of interfaces" 183
        "II.12.1  Implementing interfaces" 183
        "II.12.2  Implementing virtual methods on interfaces" 183
            "II.12.2.1  Interface Implementation Examples" 185
    "II.13 Semantics of value types" 188
        "II.13.1  Referencing value types" 189
        "II.13.2  Initializing value types" 189
        "II.13.3  Methods of value types" 190
    "II.14 Semantics of special types" 192
        "II.14.1  Vectors" 192
        "II.14.2  Arrays" 192
        "II.14.3  Enums" 194
        "II.14.4  Pointer types" 195
            "II.14.4.1  Unmanaged pointers" 196
            "II.14.4.2  Managed pointers" 197
        "II.14.5  Method pointers" 197
        "II.14.6  Delegates" 198
            "II.14.6.1  Delegate signature compatibility" 199
            "II.14.6.2  Synchronous calls to delegates" 200
            "II.14.6.3  Asynchronous calls to delegates" 201
                "II.14.6.3.1  The BeginInvoke method" 201
                "II.14.6.3.2  The EndInvoke method" 201
    "II.15 Defining, referencing, and calling methods" 203
        "II.15.1  Method descriptors" 203
            "II.15.1.1  Method declarations" 203
            "II.15.1.2  Method definitions" 203
            "II.15.1.3  Method references" 203
            "II.15.1.4  Method implementations" 203
        "II.15.2  Static, instance, and virtual methods" 203
        "II.15.3  Calling convention" 204
        "II.15.4  Defining methods" 205
            "II.15.4.1  Method body" 206
                "II.15.4.1.1  The .emitbyte directive" 207
                "II.15.4.1.2  The .entrypoint directive" 207
                "II.15.4.1.3  The .locals directive" 207
                "II.15.4.1.4  The .param directive" 208
                "II.15.4.1.5  The .param type directive" 208
            "II.15.4.2  Predefined attributes on methods" 208
                "II.15.4.2.1  Accessibility information" 209
                "II.15.4.2.2  Method contract attributes" 209
                "II.15.4.2.3  Overriding behavior" 210
                "II.15.4.2.4  Method attributes" 210
                "II.15.4.2.5  Interoperation attributes" 210
                "II.15.4.2.6  Special handling attributes" 210
            "II.15.4.3  Implementation attributes of methods" 210
                "II.15.4.3.1  Code implementation attributes" 211
                "II.15.4.3.2  Managed or unmanaged" 211
                "II.15.4.3.3  Implementation information" 211
            "II.15.4.4  Scope blocks" 212
            "II.15.4.5  vararg methods" 212
        "II.15.5  Unmanaged methods" 213
            "II.15.5.1  Method transition thunks" 213
            "II.15.5.2  Platform invoke" 214
            "II.15.5.3  Method calls via function pointers" 215
            "II.15.5.4  Data type marshaling" 215
    "II.16 Defining and referencing fields" 216
        "II.16.1  Attributes of fields" 216
            "II.16.1.1  Accessibility information" 217
            "II.16.1.2  Field contract attributes" 217
            "II.16.1.3  Interoperation attributes" 217
            "II.16.1.4  Other attributes" 218
        "II.16.2  Field init metadata" 218
        "II.16.3  Embedding data in a PE file" 219
            "II.16.3.1  Data declaration" 219
            "II.16.3.2  Accessing data from the PE file" 220
        "II.16.4  Initialization of non-literal static data" 220
            "II.16.4.1  Data known at link time" 220
        "II.16.5  Data known at load time" 221
            "II.16.5.1  Data known at run time" 221
    "II.17 Defining properties" 222
    "II.18 Defining events" 224
    "II.19 Exception handling" 227
        "II.19.1  Protected blocks" 227
        "II.19.2  Handler blocks" 227
        "II.19.3  Catch blocks" 228
        "II.19.4  Filter blocks" 228
        "II.19.5  Finally blocks" 229
        "II.19.6  Fault handlers" 229
    "II.20 Declarative security" 230
    "II.21 Custom attributes" 231
        "II.21.1  CLS conventions: custom attribute usage" 231
        "II.21.2  Attributes used by the CLI" 231
            "II.21.2.1  Pseudo custom attributes" 232
            "II.21.2.2  Custom attributes defined by the CLS" 233
            "II.21.2.3  Custom attributes for security" 233
            "II.21.2.4  Custom attributes for TLS" 233
            "II.21.2.5  Custom attributes, various" 234
    "II.22 Metadata logical format: tables" 235
        "II.22.1  Metadata validation rules" 236
        "II.22.2  Assembly : 0x20" 237
        "II.22.3  AssemblyOS : 0x22" 238
        "II.22.4  AssemblyProcessor : 0x21" 238
        "II.22.5  AssemblyRef : 0x23" 238
        "II.22.6  AssemblyRefOS : 0x25" 239
        "II.22.7  AssemblyRefProcessor : 0x24" 239
        "II.22.8  ClassLayout : 0x0F" 240
        "II.22.9  Constant : 0x0B" 242
        "II.22.10  CustomAttribute : 0x0C" 242
        "II.22.11  DeclSecurity : 0x0E" 244
        "II.22.12  EventMap : 0x12" 246
        "II.22.13  Event : 0x14" 246
        "II.22.14  ExportedType : 0x27" 248
        "II.22.15  Field : 0x04" 249
        "II.22.16  FieldLayout : 0x10" 251
        "II.22.17  FieldMarshal : 0x0D" 252
        "II.22.18  FieldRVA : 0x1D" 253
        "II.22.19  File : 0x26" 253
        "II.22.20  GenericParam : 0x2A" 254
        "II.22.21  GenericParamConstraint : 0x2C" 255
        "II.22.22  ImplMap : 0x1C" 256
        "II.22.23  InterfaceImpl : 0x09" 257
        "II.22.24  ManifestResource : 0x28" 257
        "II.22.25  MemberRef : 0x0A" 258
        "II.22.26  MethodDef : 0x06" 259
        "II.22.27  MethodImpl : 0x19" 262
        "II.22.28  MethodSemantics : 0x18" 263
        "II.22.29  MethodSpec : 0x2B" 264
        "II.22.30  Module : 0x00" 265
        "II.22.31  ModuleRef : 0x1A" 265
        "II.22.32  NestedClass : 0x29" 266
        "II.22.33  Param : 0x08" 266
        "II.22.34  Property : 0x17" 267
        "II.22.35  PropertyMap : 0x15" 268
        "II.22.36  StandAloneSig : 0x11" 269
        "II.22.37  TypeDef : 0x02" 269
        "II.22.38  TypeRef : 0x01" 273
        "II.22.39  TypeSpec : 0x1B" 274
    "II.23 Metadata logical format: other structures" 275
        "II.23.1  Bitmasks and flags" 275
            "II.23.1.1  Values for AssemblyHashAlgorithm" 275
            "II.23.1.2  Values for AssemblyFlags" 275
            "II.23.1.3  Values for Culture" 275
            "II.23.1.4  Flags for events [EventAttributes]" 276
            "II.23.1.5  Flags for fields [FieldAttributes]" 276
            "II.23.1.6  Flags for files [FileAttributes]" 277
            "II.23.1.7  Flags for Generic Parameters [GenericParamAttributes]" 277
            "II.23.1.8  Flags for ImplMap [PInvokeAttributes]" 277
            "II.23.1.9  Flags for ManifestResource [ManifestResourceAttributes]" 278
            "II.23.1.10  Flags for methods [MethodAttributes]" 278
            "II.23.1.11  Flags for methods [MethodImplAttributes]" 279
            "II.23.1.12  Flags for MethodSemantics [MethodSemanticsAttributes]" 279
            "II.23.1.13  Flags for params [ParamAttributes]" 279
            "II.23.1.14  Flags for properties [PropertyAttributes]" 280
            "II.23.1.15  Flags for types [TypeAttributes]" 280
            "II.23.1.16  Element types used in signatures" 281
        "II.23.2  Blobs and signatures" 283
            "II.23.2.1  MethodDefSig" 285
            "II.23.2.2  MethodRefSig" 286
            "II.23.2.3  StandAloneMethodSig" 287
            "II.23.2.4  FieldSig" 288
            "II.23.2.5  PropertySig" 288
            "II.23.2.6  LocalVarSig" 289
            "II.23.2.7  CustomMod" 289
            "II.23.2.8  TypeDefOrRefOrSpecEncoded" 290
            "II.23.2.9  Constraint" 290
            "II.23.2.10  Param" 290
            "II.23.2.11  RetType" 291
            "II.23.2.12  Type" 291
            "II.23.2.13  ArrayShape" 291
            "II.23.2.14  TypeSpec" 292
            "II.23.2.15  MethodSpec" 292
            "II.23.2.16  Short form signatures" 293
        "II.23.3  Custom attributes" 293
        "II.23.4  Marshalling descriptors" 295
    "II.24 Metadata physical layout" 297
        "II.24.1  Fixed fields" 297
        "II.24.2  File headers" 297
            "II.24.2.1  Metadata root" 297
            "II.24.2.2  Stream header" 298
            "II.24.2.3  #Strings heap" 298
            "II.24.2.4  #US and #Blob heaps" 298
            "II.24.2.5  #GUID heap" 298
            "II.24.2.6  #~ stream" 299
    "II.25 File format extensions to PE" 303
        "II.25.1  Structure of the runtime file format" 303
        "II.25.2  PE headers" 303
            "II.25.2.1  MS-DOS header" 304
            "II.25.2.2  PE file header" 304
                "II.25.2.2.1  Characteristics" 304
            "II.25.2.3  PE optional header" 305
                "II.25.2.3.1  PE header standard fields" 305
                "II.25.2.3.2  PE header Windows NT-specific fields" 305
                "II.25.2.3.3  PE header data directories" 306
        "II.25.3  Section headers" 307
            "II.25.3.1  Import Table and Import Address Table (IAT)" 308
            "II.25.3.2  Relocations" 308
            "II.25.3.3  CLI header" 309
                "II.25.3.3.1  Runtime flags" 309
                "II.25.3.3.2  Entry point metadata token" 310
                "II.25.3.3.3  Vtable fixup" 310
                "II.25.3.3.4  Strong name signature" 310
        "II.25.4  Common Intermediate Language physical layout" 310
            "II.25.4.1  Method header type values" 311
            "II.25.4.2  Tiny format" 311
            "II.25.4.3  Fat format" 311
            "II.25.4.4  Flags for method headers" 311
            "II.25.4.5  Method data section" 312
            "II.25.4.6  Exception handling clauses" 312
"Common Language Infrastructure (CLI) Partition III: CIL Instruction Set  " 314
    "III.1 Introduction" 316
        "III.1.1  Data types" 316
            "III.1.1.1  Numeric data types" 317
            "III.1.1.2  Boolean data type" 319
            "III.1.1.3  Character data type" 319
            "III.1.1.4  Object references" 319
            "III.1.1.5  Runtime pointer types" 319
                "III.1.1.5.1  Unmanaged pointers" 320
                "III.1.1.5.2  Managed pointers (type &)" 320
        "III.1.2  Instruction variant table" 321
            "III.1.2.1  Opcode encodings" 321
        "III.1.3  Stack transition diagram" 327
        "III.1.4  English description" 328
        "III.1.5  Operand type table" 328
        "III.1.6  Implicit argument coercion" 331
        "III.1.7  Restrictions on CIL code sequences" 332
            "III.1.7.1  The instruction stream" 333
            "III.1.7.2  Valid branch targets" 333
            "III.1.7.3  Exception ranges" 333
            "III.1.7.4  Must provide maxstack" 334
            "III.1.7.5  Backward branch constraints" 334
            "III.1.7.6  Branch verification constraints" 334
        "III.1.8  Verifiability and correctness" 334
            "III.1.8.1  Flow control restrictions for verifiable CIL" 335
                "III.1.8.1.1  Verification algorithm" 335
                "III.1.8.1.2  Verification type system" 337
                "III.1.8.1.3  Merging stack states" 339
                "III.1.8.1.4  Class and object initialization rules" 339
                "III.1.8.1.5  Delegate construction" 339
        "III.1.9  Metadata tokens" 339
        "III.1.10  Exceptions thrown" 340
    "III.2 Prefixes to instructions" 341
        "III.2.1  constrained. – (prefix) invoke a member on a value of a variable type" 342
        "III.2.2  no. – (prefix) possibly skip a fault check" 344
        "III.2.3  readonly. (prefix) – following instruction returns a controlled-mutability managed pointer" 345
        "III.2.4  tail. (prefix) – call terminates current method" 346
        "III.2.5  unaligned. (prefix) – pointer instruction might be unaligned" 347
        "III.2.6  volatile. (prefix) – pointer reference is volatile" 348
    "III.3 Base instructions" 349
        "III.3.1  add – add numeric values" 350
        "III.3.2  add.ovf.<signed> – add integer values with overflow check" 351
        "III.3.3  and – bitwise AND" 352
        "III.3.4  arglist – get argument list" 353
        "III.3.5  beq.<length> – branch on equal" 354
        "III.3.6  bge.<length> – branch on greater than or equal to" 355
        "III.3.7  bge.un.<length> – branch on greater than or equal to, unsigned or unordered" 356
        "III.3.8  bgt.<length> – branch on greater than" 357
        "III.3.9  bgt.un.<length> – branch on greater than, unsigned or unordered" 358
        "III.3.10  ble.<length> – branch on less than or equal to" 359
        "III.3.11  ble.un.<length> – branch on less than or equal to, unsigned or unordered" 360
        "III.3.12  blt.<length> – branch on less than" 361
        "III.3.13  blt.un.<length> – branch on less than, unsigned or unordered" 362
        "III.3.14  bne.un<length> – branch on not equal or unordered" 363
        "III.3.15  br.<length> – unconditional branch" 364
        "III.3.16  break – breakpoint instruction" 365
        "III.3.17  brfalse.<length> – branch on false, null, or zero" 366
        "III.3.18  brtrue.<length> – branch on non-false or non-null" 367
        "III.3.19  call – call a method" 368
        "III.3.20  calli – indirect method call" 370
        "III.3.21  ceq – compare equal" 372
        "III.3.22  cgt – compare greater than" 373
        "III.3.23  cgt.un – compare greater than, unsigned or unordered" 374
        "III.3.24  ckfinite – check for a finite real number" 375
        "III.3.25  clt – compare less than" 376
        "III.3.26  clt.un – compare less than, unsigned or unordered" 377
        "III.3.27  conv.<to type> – data conversion" 378
        "III.3.28  conv.ovf.<to type> – data conversion with overflow detection" 379
        "III.3.29  conv.ovf.<to type>.un – unsigned data conversion with overflow detection" 380
        "III.3.30  cpblk – copy data from memory to memory" 381
        "III.3.31  div – divide values" 382
        "III.3.32  div.un – divide integer values, unsigned" 383
        "III.3.33  dup – duplicate the top value of the stack" 384
        "III.3.34  endfilter – end exception handling filter clause" 385
        "III.3.35  endfinally – end the finally or fault clause of an exception block" 386
        "III.3.36  initblk – initialize a block of memory to a value" 387
        "III.3.37  jmp – jump to method" 388
        "III.3.38  ldarg.<length> – load argument onto the stack" 389
        "III.3.39  ldarga.<length> – load an argument address" 390
        "III.3.40  ldc.<type> – load numeric constant" 391
        "III.3.41  ldftn – load method pointer" 392
        "III.3.42  ldind.<type> – load value indirect onto the stack" 393
        "III.3.43  ldloc – load local variable onto the stack" 395
        "III.3.44  ldloca.<length> – load local variable address" 396
        "III.3.45  ldnull – load a null pointer" 397
        "III.3.46  leave.<length> – exit a protected region of code" 398
        "III.3.47  localloc – allocate space in the local dynamic memory pool" 399
        "III.3.48  mul – multiply values" 400
        "III.3.49  mul.ovf.<type> – multiply integer values with overflow check" 401
        "III.3.50  neg – negate" 402
        "III.3.51  nop – no operation" 403
        "III.3.52  not – bitwise complement" 404
        "III.3.53  or – bitwise OR" 405
        "III.3.54  pop – remove the top element of the stack" 406
        "III.3.55  rem – compute remainder" 407
        "III.3.56  rem.un – compute integer remainder, unsigned" 408
        "III.3.57  ret – return from method" 409
        "III.3.58  shl – shift integer left" 410
        "III.3.59  shr – shift integer right" 411
        "III.3.60  shr.un – shift integer right, unsigned" 412
        "III.3.61  starg.<length> – store a value in an argument slot" 413
        "III.3.62  stind.<type> – store value indirect from stack" 414
        "III.3.63  stloc – pop value from stack to local variable" 415
        "III.3.64  sub – subtract numeric values" 416
        "III.3.65  sub.ovf.<type> – subtract integer values, checking for overflow" 417
        "III.3.66  switch – table switch based on value" 418
        "III.3.67  xor – bitwise XOR" 419
    "III.4 Object model instructions" 420
        "III.4.1  box – convert a boxable value to its boxed form" 420
        "III.4.2  callvirt – call a method associated, at runtime, with an object" 422
        "III.4.3  castclass – cast an object to a class" 424
        "III.4.4  cpobj – copy a value from one address to another" 425
        "III.4.5  initobj – initialize the value at an address" 426
        "III.4.6  isinst – test if an object is an instance of a class or interface" 427
        "III.4.7  ldelem – load element from array" 428
        "III.4.8  ldelem.<type> – load an element of an array" 429
        "III.4.9  ldelema – load address of an element of an array" 431
        "III.4.10  ldfld – load field of an object" 432
        "III.4.11  ldflda – load field address" 433
        "III.4.12  ldlen – load the length of an array" 434
        "III.4.13  ldobj – copy a value from an address to the stack" 435
        "III.4.14  ldsfld – load static field of a class" 436
        "III.4.15  ldsflda – load static field address" 437
        "III.4.16  ldstr – load a literal string" 438
        "III.4.17  ldtoken – load the runtime representation of a metadata token" 439
        "III.4.18  ldvirtftn – load a virtual method pointer" 440
        "III.4.19  mkrefany – push a typed reference on the stack" 441
        "III.4.20  newarr – create a zero-based, one-dimensional array" 442
        "III.4.21  newobj – create a new object" 443
        "III.4.22  refanytype – load the type out of a typed reference" 446
        "III.4.23  refanyval – load the address out of a typed reference" 447
        "III.4.24  rethrow – rethrow the current exception" 448
        "III.4.25  sizeof – load the size, in bytes,of a type" 449
        "III.4.26  stelem – store element to array" 450
        "III.4.27  stelem.<type> – store an element of an array" 451
        "III.4.28  stfld – store into a field of an object" 453
        "III.4.29  stobj – store a value at an address" 454
        "III.4.30  stsfld – store a static field of a class" 455
        "III.4.31  throw – throw an exception" 456
        "III.4.32  unbox – convert boxed value type to its raw form" 457
        "III.4.33  unbox.any – convert boxed type to value" 458
"Common Language Infrastructure (CLI) Partition IV: Profiles and Libraries    " 459
    "IV.1 Overview" 460
    "IV.2 Libraries and Profiles" 461
        "IV.2.1  Libraries" 461
        "IV.2.2  Profiles" 461
        "IV.2.3  The relationship between Libraries and Profiles" 462
    "IV.3 The Standard Profiles" 463
        "IV.3.1  The Kernel Profile" 463
        "IV.3.2  The Compact Profile" 463
    "IV.4 Kernel Profile feature requirements" 464
        "IV.4.1  Features excluded from the Kernel Profile" 464
            "IV.4.1.1  Floating point" 464
            "IV.4.1.2  Non-vector arrays" 464
            "IV.4.1.3  Reflection" 464
            "IV.4.1.4  Application domains" 465
            "IV.4.1.5  Remoting" 465
            "IV.4.1.6  Vararg" 465
            "IV.4.1.7  Frame growth" 465
            "IV.4.1.8  Filtered exceptions" 465
    "IV.5 The standard libraries" 466
        "IV.5.1  General comments" 466
        "IV.5.2  Runtime infrastructure library" 466
        "IV.5.3  Base Class Library (BCL)" 466
        "IV.5.4  Network library" 466
        "IV.5.5  Reflection library" 466
        "IV.5.6  XML library" 466
        "IV.5.7  Extended numerics library" 467
        "IV.5.8  Extended array library" 467
        "IV.5.9  Vararg library" 467
        "IV.5.10  Parallel library" 467
    "IV.6 Implementation-specific modifications to the system libraries" 469
    "IV.7 The XML specification" 470
        "IV.7.1  Semantics" 470
            "IV.7.1.1  Value types as objects" 478
            "IV.7.1.2  Exceptions" 478
        "IV.7.2  XML signature notation issues" 478
            "IV.7.2.1  Serialization" 478
            "IV.7.2.2  Delegates" 478
            "IV.7.2.3  Properties" 479
            "IV.7.2.4  Nested types" 479
"Common Language Infrastructure (CLI) Partition V: Debug Interchange Format    " 480
    "V.1 Portable CILDB files" 481
        "V.1.1  Encoding of integers" 481
        "V.1.2  CILDB header" 481
            "V.1.2.1  Version GUID" 481
        "V.1.3  Tables and heaps" 481
            "V.1.3.1  SymConstant table" 482
            "V.1.3.2  SymDocument table" 482
            "V.1.3.3  SymMethod table" 482
            "V.1.3.4  SymSequencePoint table" 483
            "V.1.3.5  SymScope table" 483
            "V.1.3.6  SymVariable table" 483
            "V.1.3.7  SymUsing table" 484
            "V.1.3.8  SymMisc heap" 484
            "V.1.3.9  SymString heap" 484
        "V.1.4  Signatures" 484
"Common Language Infrastructure (CLI) Partition VI: Annexes " 485
    "VI.Annex A Introduction" 487
    "VI.Annex B Sample programs" 488
        "VI.B.1  Mutually recursive program (with tail calls)" 488
        "VI.B.2  Using value types" 489
        "VI.B.3  Custom attributes" 491
        "VI.B.4  Generics code and metadata" 494
            "VI.B.4.1  ILAsm version" 494
            "VI.B.4.2  C# version" 495
            "VI.B.4.3  Metadata" 495
    "VI.Annex C CIL assembler implementation" 497
        "VI.C.1  ILAsm keywords" 497
        "VI.C.2  CIL opcode descriptions" 509
        "VI.C.3  Complete grammar" 520
        "VI.C.4  Instruction syntax" 535
            "VI.C.4.1  Top-level instruction syntax" 536
            "VI.C.4.2  Instructions with no operand" 536
            "VI.C.4.3  Instructions that refer to parameters or local varia bles" 537
            "VI.C.4.4  Instructions that take a single 32-bit integer argument" 538
            "VI.C.4.5  Instructions that take a single 64-bit integer argument" 538
            "VI.C.4.6  Instructions that take a single floating-point argument" 538
            "VI.C.4.7  Branch instructions" 539
            "VI.C.4.8  Instructions that take a method as an argument" 539
            "VI.C.4.9  Instructions that take a field of a class as an argument" 539
            "VI.C.4.10  Instructions that take a type as an argument" 539
            "VI.C.4.11  Instructions that take a string as an argument" 540
            "VI.C.4.12  Instructions that take a signature as an argumen t " 540
            "VI.C.4.13  Instructions that take a metadata token as an argument" 540
            "VI.C.4.14  Switch instruction" 541
    "VI.Annex D Class library design guidelines" 542
    "VI.Annex E Portability considerations" 543
        "VI.E.1  Uncontrollable behavior" 543
        "VI.E.2  Language- and compiler-controllable behavior" 543
        "VI.E.3  Programmer-controllable behavior" 543
    "VI.Annex F Imprecise faults" 545
        "VI.F.1 Instruction reordering" 545
        "VI.F.2 Inlining" 545
        "VI.F.3 Finally handlers still guaranteed once a try block is entered" 545
        "VI.F.4 Interleaved calls" 546
            "VI.F.4.1  Rejected notions for fencing" 546
        "VI.F.5 Examples" 546
            "VI.F.5.1  Hoisting checks out of a loop" 547
            "VI.F.5.2  Vectorizing a loop" 547
            "VI.F.5.3  Autothreading a loop" 547
    "VI.Annex G Parallel library" 549
        "VI.G.1  Considerations" 549
        "VI.G.2  ParallelFor" 549
        "VI.G.3  ParallelForEach" 549
        "VI.G.4  ParallelWhile" 550
        "VI.G.5  Debugging" 550
    "Index" 551
